---
slug: 'how-to-create-a-fullstack-application-using-django-and-python-part-31'
date: '2024-11-23T23:43:58.688Z'
lastModified: '2024-11-28T13:00:58.688Z'
title: 'How to create a fullstack application using Django and Python Part 31'
author: 'Maria D. Campbell'
excerpt:
    'In this section, I modify settings in django_boards/settings.py for deployment
on Heroku. I create a new SECRET_KEY for use on Heroku, add gunicorn,
dj-database-url, psycopg2 and psycopg2-binary packages, create a
requirements.txt file, create a Procfile, create a .python-version file,
discuss the purpose of the os module, set DEBUG to false on Heroku,
differentiate between DEBUG value in local development and production on
Heroku, configure database access, run the collectstatic command for serving
static files in production, and install and configure whitenoise.'
image: elin-gann-XBb6qMPGmV0-unsplash.jpg
tags:
    [
        'fullstack development',
        'macOS',
        'heroku',
        'deployment',
        'django',
        'python3',
        'database access',
        'database configuration',
        'development',
        'gunicorn',
        'heroku postgres',
        'procfile',
        'production',
        'static files',
        'whitenoise',
        'series',
    ]
isPublished: true
isFeatured: false
---

![Swedish chocolate balls, cinnamon roll and cardamom rolls in an autumn setting.](elin-gann-XBb6qMPGmV0-unsplash.jpg)

**_Photo by_** [Elin Gann](https://unsplash.com/@elsekind) **_on_**
[unsplash.com](https://unsplash.com/photos/a-table-topped-with-plates-of-food-covered-in-powdered-sugar-XBb6qMPGmV0)

**Important Note**: `Before` committing `anything` to `Git` or `pushing`
anything to `remote`, please visit
[How to create a fullstack application using Django and Python Part 4](http://localhost:3000/blog/how-to-create-a-fullstack-application-using-django-and-python-part-4)
`where` I `discuss` how to `add` the `python-dotenv` package to the `Django`
site and `why` it is `crucial` to `do it`. This article `assumes` you have a
`working knowledge` of `Git`.

## Table of Contents

-   [Saving the current settings.py in case if things go wrong](#saving-the-current-settingspy-in-case-if-things-go-wrong)
-   [Preparing for deployment on Heroku](#preparing-for-deployment-on-heroku)
-   [Configuring our Django app for Heroku](#configuring-our-django-app-for-heroku)

    -   [Creating a new SECRET_KEY for use on Heroku](#creating-a-new-secret-key-for-use-on-heroku)
    -   [Adding gunicorn, dj-database-url, psycopg2 and psycopg2-binary packages](#adding-gunicorn-dj-database-url-psycopg2-and-psycopg2-binary-packages)
    -   [Creating a requirements.txt file](#creating-a-requirementstxt-file)
    -   [Creating a Procfile](#creating-a-procfile)
    -   [Creating a runtime.txt file/.python-version file](#creating-a-runtimetxt-file-python-version-file)
    -   [The os module](#the-os-module)
    -   [Setting DEBUG to False on Heroku](#setting-debug-to-false-on-heroku)
    -   [Differentiating between DEBUG value in local development and production on Heroku](#differentiating-between-debug-value-in-local-development-and-production-on-heroku)
    -   [Configuring database access](#configuring-database-access)

-   [Static Files](#static-files)
    -   [Running the collectstatic command](#running-the-collectstatic-command)
    -   [Installing whitenoise](#installing-whitenoise)
    -   [Configuring whitenoise in django_boards/settings.py](#configuring-whitenoise-in-django-boards-settingspy)
-   [Media Files](#media-files)
    -   [Media Files in development mode](#media-files-in-development-mode)
    -   [Media Files in production](#media-files-in-production)
-   [django_boards/settings.py up to this point](#django-boards-settingspy-up-to-this-point)
-   [Conclusion](#conclusion)
-   [Related Resources](#related-resources)
-   [Related Posts](#related-posts)

## Saving the current settings.py in case if things go wrong

In case if things go wrong, make sure that you save the contents of your
`settings.py` file so that you can `revert` to it if necessary. Also make sure
to save the key value pair of your original `SECRET_KEY` so that you can revert
to your original local state. For me, it was still present when I merged the
branch 'create-like-post-tests' into the main branch:

-   [Merge branch 'create-like-post-tests'](https://github.com/interglobalmedia/django-boards/commit/9fef46ac55060957f2014f5d9b487e54cebed5eb)

I had not created a new branch when I `reset` my `settings.py` to its _original_
`local state`, so what I did was `stash` my `settings.py` changes, `create` a
_new_ `branch` called `resetting-settingspy-to-original-local-state`,
`committed` _those_ `changes`, `checked out` into the `main` branch, `merged`
that `branch` into the `main` branch, and then `pushed` _those_ `changes` to
`GitHub`:

```shell
git status
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   django_boards/settings.py

no changes added to commit (use "git add" and/or "git commit -a")

git stash -u
Saved working directory and index state WIP on main: b6cdc6f Clean up static config

git checkout -b resetting-settingspy-to-original-local-state
git stash apply
On branch resetting-settingspy-to-original-local-state
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   django_boards/settings.py

no changes added to commit (use "git add" and/or "git commit -a")

git status
On branch resetting-settingspy-to-original-local-state
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   django_boards/settings.py

no changes added to commit (use "git add" and/or "git commit -a")

git add django_boards/settings.py

git commit
[resetting-settingspy-to-original-local-state ff95089] Reset settings.py to original local state
 1 file changed, 69 insertions(+), 143 deletions(-)

git status
On branch resetting-settingspy-to-original-local-state
nothing to commit, working tree clean

git checkout main
Switched to branch 'main'
Your branch is up to date with 'origin/main'.

git merge resetting-settingspy-to-original-local-state --no-ff
Merge made by the 'ort' strategy.
 django_boards/django_boards/settings.py | 212 ++++++++++++++++++++++++-------------------------------------------------
 1 file changed, 69 insertions(+), 143 deletions(-)

git push origin main
Enumerating objects: 10, done.
Counting objects: 100% (10/10), done.
Delta compression using up to 10 threads
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 1.31 KiB | 1.31 MiB/s, done.
Total 6 (delta 5), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (5/5), completed with 4 local objects.
remote:
remote: GitHub found 2 vulnerabilities on interglobalmedia/django-boards's default branch (2 moderate). To find out more, visit:
remote:      https://github.com/interglobalmedia/django-boards/security/dependabot
remote:
To github.com:interglobalmedia/django-boards.git
   b6cdc6f..e0fe33c  main -> main
```

_This_ `makes` it `easier` for me to `track` at which `point` I `reset` my
`settings.py` file. The `name` of the `branch` _describes_ the `changes` I
`made` _within the_ `branch` so that when I` go` into my `Git` history in my
`repository` on `GitHub`, I `will` be `able` _to easily_ `identify` the `point`
in `time` _that_ `change`/`those changes` _were_ `made`.

Please `ignore` other `commits` made `directly` in the `main` branch `after`
that. They were my `desperate attempts` at `configuring` my `django-boards`
structure to `Heroku`'s `requirements`, `package requirements`, and
`settings.py`. I will `share` the `link` to the `successful configuration` of
django-boards `settings.py` at the `end` of this `post` for `reference`.

## Preparing for deployment on Heroku

`In order` to `be able` to `deploy` our `django-boards` app on `Heroku`, `some`
of the `things` we `have` to `do` are the `following`:

-   Have an account on Heroku
-   Install the heroku CLI
-   Create a Python application on Heroku
-   Add a postgres database add-on to our Heroku application
-   Create a new SECRET_KEY for Heroku app
-   Create a Procfile

`Once` we have `created` an `account` on `Heroku`, we `have` to `install` the
`Heroku CLI`. For those of you that are on `macOS` like myself, `run` _the
following_ `command`:

```shell
brew tap heroku/brew && brew install heroku
```

This does `assume` that you `already` have `Homebrew` installed. `In order` _to
install_ `Homebrew` on `macOS`, `run` the following `command`:

```shell
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

To `learn more` about `Homebrew`, please `visit` the
[Homebrew home page](https://brew.sh).

`Once` _we have_ `installed` the `Heroku CLI`, we can `run` _the following_
`command`:

```shell
heroku login
```

We are then `prompted` _to open_ `Heroku` in our `web browser` _and to_ `login`
to `Heroku`.

`After` we `have` successfully `logged` into `Heroku`, we can `create` our
`app`. I `ran` _the following_ `command` to `create` an `app` called
`django-boards`:

```shell
heroku create django-boards
```

`After` it was `created`, I `ran` the `following`:

```shell
# if I have any changes to push ro GitHub
git add .
git commit
git push origin main
# then I simply have to push those changes to heroku
git push heroku main
```

and my `django-boards` app is `pushed` to `Heroku`.

`Make sure` that you have `connected` the correct `GitHub` repository with your
`Heroku` app. To `learn more` about `how` _to enable_ `GitHub` integration with
your `Heroku` app, please `visit`
[GitHub Integration (Heroku GitHub Deploys)]().https://devcenter.heroku.com/articles/github-integration

If I `want` to `check` what my `git remote URL`s are on `Heroku`, I can `run`
_the following_ `command` from the `directory` where my `manage.py` resides:

```shell
django_boards git remote -v
```

And the `following` is `returned`:

```shell
heroku  https://git.heroku.com/django-boards.git (fetch)
heroku  https://git.heroku.com/django-boards.git (push)
origin  git@github.com:interglobalmedia/django-boards.git (fetch)
origin  git@github.com:interglobalmedia/django-boards.git (push)
```

Then, to `open` my `application`, I run:

```shell
heroku open
```

`At` _this_ `point`, our `app` will `not` be `working` on `Heroku`. We `have`
_to further_ `configure` our `app` for `Heroku`.

## Configuring our Django app for Heroku

### Creating a new SECRET_KEY for use on Heroku

_Next_, we `create` _a new_ `SECRET_KEY` using the `following command` for `use`
on `Heroku`:

```shell
python manage.py shell
>>> import secrets
>>> secret_key = secrets.token_urlsafe(100)
>>> print(secret_key)
HPXglo0sJsGs_bnrM0Eipkf_TkT9Rrl4_GKyW0uHTP9lgSOqxaqkX53mnwt2zqbUIRvYMhWnFQHHPBokUWc-qPsaWH_T1QWWmeSE9VUzf9DR6xg3M1nslC-0SPsbVDbkkIucoQ
```

I `chose` to `set` a `random key` that is `100` bytes in `size`, or `134`
_characters_ `long`. This `should` be `large/long` enough `to be` secure.

We `use` the Python `secrets` module to `create` a `long` _random_ `secret key`.
We `pass` in the `byte size` we `want` to the `secrets.token_urlsafe()` method.

The `secrets` module is `designed` for `generating` _cryptographically_ `strong`
random `values`, `making` it `ideal` _for creating_ `secure keys`.

The `token_urlsafe(n)` method `generates` a `random` _URL-safe_ `string`
_containing_ `n bytes`. I `use` 100 `bytes` here, which `results` in a
`134-character` string.

`After` we `generate` the `key` we `copy` the `newly` _generated_ `string` of
`characters` and `paste` them `as` the `value` of the `SECRET_KEY` variable
`inside` our `.env` file as `well` as the `value` of a `SECRET_KEY` environment
`variable` inside our `django-boards` application's `Settings` tab on `Heroku`.

### Adding gunicorn, dj-database-url, psycopg2 and psycopg2-binary packages

_Next_, with our `virtual` _environment_ `activated` at the `root directory` of
our `Django` application (`django-boards`), we `run` _the following_ `command`:

```shell
django-boards (venv) pip install gunicorn psycopg2 psycopg2-binary dj-database-url
```

### Creating a requirements.txt file

_Now_ that we have `added` _more_ `packages` to `django-boards` and we are
`preparing` for `deployment`, we `need` to `create` a `requirements.txt` file
which will `contain` all the `packages` _required_ for our `Django` application
to `run` in `production`.

_First_, we `have` to `create` a `requirements.txt` file at the `root` of our
`local` Git `repository` _where_ `files` _such as_ `.gitignore` reside. To
`create` it, we `run` _the following_ `command` in the `root` of the
`django-boards` repository:

```shell
pip freeze > requirements.txt
```

_This_ `command` _generates a_ `list` of `all` _installed_ `packages` and their
`versions` _within my_ `virtual environment`. I `removed` a `couple` of `them`
that I `ended up` _not_ `using` in the `project`. _Now_ the `hosting provider`
_will_ `know` _which_ `packages` to `install` when I `deploy` my `project`.

As usual, `before` _installing_ `something`, I `had` to `make sure` that I had
`activated` my `virtual environment`:

```shell
source venv/bin/activate
```

If you are not sure whether you re-ran `pip freeze > requirements.txt` to
include latest installs, just run `pip freeze > requirements.txt` again. You can
`check` your `requirements.txt` file to `make sure` that `all` your
`required dependencies` are `included` there.

If ever you `uninstall` a `package`, run `pip freeze > requirements.txt` again.

### Creating a Procfile

We `need` a `Procfile` _for any_ `application` we `host` on `Heroku`. In the
`case` of a `Django` application, we `need` to `add` the `following` to a `file`
called `Procfile`:

```shell
web: gunicorn --pythonpath django_boards django_boards.wsgi --log-file -
```

It should `reside` in the `root` of our `local` Git `repository`, `where` _such_
`files` as `.gitignore` reside. `In` our `case`, `because` of the `structure` of
our `Django` application, we `must` _add_ `django_boards` _before_
`django_boards.wsgi`, because `files` like `manage.py` _reside_ `in` the first
`django_boards` subdirectory of our `local` Git `repository`.

The `Procfile` _specifies the_ `commands` to `run` when our `application`
starts. `In` our `file`, _we instruct_ `Heroku` _to use_ `Gunicorn` to `start`
our `Django` application.

`Gunicorn` plays a `crucial role` _when deploying_ `Django` applications on
`Heroku`. It is a `Python` _WSGI_ `HTTP server`. It `acts` as the `interface`
between our `Django` application and the `web`, `handling` _incoming_ `HTTP`
requests _and passing_ `them` to `Django` for `processing`.

`Gunicorn` _enables our_ `Django` app to `handle` _multiple_
`concurrent requests` by `utilizing` _multiple_ `worker processes`. `This`
_significantly_ `improves` the `performance` and `responsiveness` of our
`application`, `especially` _under_ `heavy traffic`.

`Gunicorn` _can gracefully_ `handle` worker `failures` _and automatically_
`restart` them.

We can easily `adjust` the `number` of `worker processes` to `match` the `load`
on our `application`.

`Gunicorn` _offers_ `various` _configuration_ `options` _to optimize_
`performance`.

Gunicorn's `--pythonpath` option `allows us` _to dynamically_ `attach` a
`directory` to the `list` of `directories` that the `Python` runtime `searches`
for when it does `module` look-ups. _By adding_ `--pythonpath` to the `gunicorn`
command, the `interpreter` is `basically` told to
`'look inside of the (outer) django_boards directory for a package (also) called django_boards which contains a module called wsgi.`

`--log-file` or `--error-logfile` _followed_ `by` a `FILE` or `-` _stands for_
the `default` _error log_ `file` to `write` to.

And `what` is the `.wsgi` file `for`?

In `Django`, the `.wsgi` file (`typically` _named_ `wsgi.py`) `serves` as the
`entry point` for our `web server` to `interact` with our `Django` application.
It `acts` as a `bridge` _between the_ `web server` (like `Gunicorn` or `Apache`)
and our `Django` application, `allowing them` to `communicate` and `handle`
requests.

When we `configure` our `web server` (e.g., `Gunicorn`), we `specify` the `path`
to our `wsgi.py` file.

The `web server` _imports the_ `application` _callable from_ `wsgi.py`. In our
`wegi.py` file in `django_boards`, our `wsgi.py` looks `something like` the
`following`:

```python
"""
WSGI config for django_boards project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_boards.settings')

application = get_wsgi_application()
```

### Creating a runtime.txt file/.python-version file

`Heroku` used to `require` a `runtime.txt` file to `specify` the `Python`
version that an `app` is `using`.` Now` it is `deprecated` and has been
`replaced` with a `.python-version` file. I `currently` have `both` a
`runtime.txt` and `.python-version` file, but will `remove` the `runtime.txt`
file `since` it is `deprecated`.

### The os module

We `need` to `make sure` we are `importing` our `os` at the `top` of
`django_boards/settings.py`. We `already` have `done` so:

```python
import os
```

`os` _refers_ `to` the `Python`'s _built-in_ `os` module. It `provides` a `way`
to `interact` with the `operating system`, `allowing us` _to perform_ `tasks`
like:

-   `File system operations` like `reading` and `writing` files,
    `creating directories`, `listing directory contents`, etc.
-   `Path manipulations` like `joining paths`, `extracting file extensions`,
    `checking` _if a_ `path` exists, etc.
-   `Accessing` and `modifying` _environment_ `variables`.
-   `Spawning new processes`, `getting process IDs`, etc.

_Specifically_, `importing` the `os` module `allows us` to `read` _environment_
`variables`.

_For example_, we will be `using` the `os` module in `the` _following_ `way` (to
be `discussed` _a bit_ `later`):

```python
IS_HEROKU_APP = "DYNO" in os.environ and not "CI" in os.environ
```

`os.environ` is a `Python` _dictionary-like_ `object` that `allows us` _to
access_ `environment variables`. _These_ `variables` are `key-value` pairs that
`store` _configuration information_ `external` to our `code`, `making` it
`easier` to `manage` and `customize` our `application` _across different_
`environments`. The `DYNO` env var is `set` on `Heroku` CI, but it's `not` _a
real_ `Heroku` app, so we also `have` to `explicitly` _exclude_ `CI`, for
example.

### Setting DEBUG to False on Heroku

```shell
django_boards heroku config:set DEBUG=False
Setting DEBUG and restarting ⬢ django-boards... done, v6
DEBUG: False
```

_Here_, _we set_ `DEBUG` to `False` on `Heroku`. _Locally_, `we` also `want` to
`make sure` that `DEBUG` is `set` to `False`. _Otherwise_, a `security warning`
_will be_ `returned` to `Terminal` _after_ `deployment`:

```shell
(security.W018) You should not have DEBUG set to True in deployment.
```

`This` is `what` was `returned` after `I` had `deployed` to `Heroku` and had
`DEBUG` set to `True` in `django_boards/settings.py`, `even though` I had `set`
_it to_ `False` on `Heroku` itself. I will `discuss` the `command` I `ran` that
`resulted` in this `warning` _a bit_ `later`.

`When` _we set_ `DEBUG` to `FALSE` (as above), we `lose` _any_ `custom styling`
(`non-Bootstrap`) as `well` as `our` _default_ `topic posts` and `post detail`
_default_ `images` locally. We will get to that later.

### Differentiating between DEBUG value in local development and production on Heroku

We also `want` to `make sure` that we can `move` between `development` mode and
`production` mode. `Heroku` _provides us_ `with` a `conditional statement` _that
achieves_ `this`:

```python
# The `DYNO` env var is set on Heroku CI, but it's not a real Heroku app, so we also have to
# explicitly exclude CI:
# https://devcenter.heroku.com/articles/heroku-ci#immutable-environment-variables
IS_HEROKU_APP = "DYNO" in os.environ and not "CI" in os.environ

# SECURITY WARNING: don't run with debug turned on in production!
if not IS_HEROKU_APP:
    DEBUG = True

# On Heroku, it's safe to use a wildcard for `ALLOWED_HOSTS``, since the Heroku router performs
# validation of the Host header in the incoming HTTP request. On other platforms you may need to
# list the expected hostnames explicitly in production to prevent HTTP Host header attacks. See:
# https://docs.djangoproject.com/en/5.1/ref/settings/#std-setting-ALLOWED_HOSTS
if IS_HEROKU_APP:
    ALLOWED_HOSTS = ["*"]
else:
    ALLOWED_HOSTS = ['localhost', '127.0.0.1']

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = False
```

`This` _also_ `includes` _differentiating between_ `ALLOWED_HOSTS` in
`production` on `Heroku` and `ALLOWED_HOSTS` in `development` locally.
`'localhost'` is `used` with the `heroku local -p PORT_NUMBER`. _Replace_
`PORT_NUMBER` _with the_ `port number` you `want` to `use`. _For example_, I
`like` _to use_ `port 8000`, so I `run` _the command_ `heroku local -p 8000`.
`'127.0.0.1'` _refers_ `to` the `IP address` we `use` when `running` in
`development`. _Specifically_, `127.0.0.1:8000`.

### Configuring database access

_Next_, we `have` to `find` the `variable` called `DATABASES`:

```python
# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```

_Again_, `Heroku` _provides us_ `with` a `conditional statement` to
`differentiate` _between our_ `sqlite3` _development_ `database` _and our_
`production database` on `Heroku`:

```python
if IS_HEROKU_APP:
    # In production on Heroku the database configuration is derived from the `DATABASE_URL`
    # environment variable by the dj-database-url package. `DATABASE_URL` will be set
    # automatically by Heroku when a database addon is attached to your Heroku app. See:
    # https://devcenter.heroku.com/articles/provisioning-heroku-postgres#application-config-vars
    # https://github.com/jazzband/dj-database-url
    DATABASES = {
        "default": dj_database_url.config(
            env="DATABASE_URL",
            conn_max_age=600,
            conn_health_checks=True,
            ssl_require=True,
        ),
    }
else:
    # When running locally in development or in CI, a sqlite database file will be used instead
    # to simplify initial setup. Longer term it's recommended to use Postgres locally too.
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }
```

This `replaces` our (_original_) `development configuration` using the `sqlite3`
database _that_ `comes` _with_ `Django`:

```python
# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```

`This` (_initial_) `configuration` is for an `sqlite3` (`SQLite`) `database`.
_However_, on `Heroku`, we would `lose` _our entire_ `database` _at least_
`once` _every_ `24 hours`.

`Even` if `Heroku`’s disks were `persistent`, _running_ `sqlite3` would
`still not` _be a_ `good fit`. Since sqlite3 _does not_ `run` _as a_ `service`,
_each_ `dyno` would `run` _a separate_ `running copy`. `Each` _of these_
`copies` _need_ `their` _own_ `disk` _backed_ `store`. `This` _would_ `mean`
_that each_ `dyno` _powering_ `our app` _would_ `have` _a different_ `set` of
`data` _since the_ `disks` _are not_ `synchronized`. _Instead_ `of` _using_
`SQLite` on `Heroku` we `configure` our `app` to `run` on `Postgres` as
`indicated` in the `if statement` above.

_However_, our `Postgres` configuration _will not_ `work` until we `run` the
_following_ `command`:

```shell
django-boards heroku run python django_boards/manage.py migrate
```

We `run` it `at` the `root` of our `local` _git_ `repository`: `django-boards`.

The `command` _returns_ `something like` the `following` in `Terminal`:

```shell
Running python django_boards/manage.py migrate on ⬢ django-boards... up, run.6305
Operations to perform:
  Apply all migrations: accounts, admin, auth, avatar, boards, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying accounts.0001_initial... OK
  Applying accounts.0002_alter_profile_avatar... OK
  Applying accounts.0003_alter_profile_avatar... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying avatar.0001_initial... OK
  Applying avatar.0002_add_verbose_names_to_avatar_fields... OK
  Applying avatar.0003_auto_20170827_1345... OK
  Applying boards.0001_initial... OK
  Applying boards.0002_remove_post_post_liked_by_post_likes_delete_postlike... OK
  Applying boards.0003_remove_post_likes... OK
  Applying boards.0004_like... OK
  Applying boards.0005_post_likes_delete_like... OK
  Applying boards.0006_remove_post_likes_topic_likes... OK
  Applying boards.0007_remove_topic_likes_post_likes... OK
  Applying boards.0008_alter_post_likes... OK
  Applying boards.0009_alter_post_likes... OK
  Applying boards.0010_alter_post_message... OK
  Applying boards.0011_alter_post_message... OK
  Applying boards.0012_alter_post_message... OK
  Applying boards.0013_alter_post_message... OK
  Applying boards.0014_remove_post_likes... OK
  Applying boards.0015_like... OK
  Applying boards.0016_alter_like_value... OK
  Applying boards.0017_post_dislikes_post_likes_delete_like... OK
  Applying boards.0018_remove_post_dislikes... OK
  Applying sessions.0001_initial... OK
```

`Before` _I finally_ `figured out` _what was_ `going on`, I `did` the
`following` (`which` definitely `was` a `hack` and `should not` _ever be_
`implemented` because `that` would `mean` that `I` _wouldn't_ `migrate` my
`database` on `Heroku`):

```python
DATABASE_URL = str(os.getenv('DATABASE_URL'))

DATABASES = {
    'default': DATABASE_URL
}
```

_It worked_ `after` _I ran_ `heroku run python django_boards/manage.py migrate`,
but it is `correct practice` _to use_ `dj_database_url.config()` instead. Just
`remember` _to also_ `set` the `DATABASE_URL` variable for `Heroku` using the
`following command`:

```shell
heroku config:set DATABASE_URL=DATABASE_URL_VALUE -a django-boards
```

We `can` _get_ `DATABASE_URL_VALUE` _from within_ `Config Vars` on `Heroku`
_within our_ `application`'s `Settings` tab. _THEN_ the
`dj_database_url.config()` `method` _will_ `work`. The `DATABASE_URL` is
`generated` _after we_ `add` the `Heroku Postgres` addon to our `Heroku`
_django-boards_ `application`.

What `dj_database_url.config()` does `is` it `reads` the `DATABASE_URL`
_environment_ `variable` _provided by_ `Heroku` and `converts` it `into` _a
format_ `Django` _can_ `understand`.

`conn_max_age=600` _keeps_ `database connections` _open_ `for` a
`longer duration` (around 10 minutes in this case), _improving_ `performance`.

`ssl_require=True` _enforces_ `secure connections` to our `database`. We `have`
to `turn` on `SSL` _from_ `within` our `application settings` on `Heroku`. It's
very `easy` to `implement`. `Once` _we have_ `done this`, we `can` _also_
`check` _what our_ `Heroku` domain for the `django-boards` application `is` by
`running` _the following_ `command`:

```shell
heroku domains
```

`which` _for_ `me`, `returned` the `following`:

```shell
=== django-boards Heroku Domain

django-boards-b087dbbc34ba.herokuapp.com
```

_If_, _however_, you `place` _the actual_ `DATABASE_URL` _in your_ `settings.py`
by `accident` (as I did) _and then_ `push` that `change` to `GitHub`, please
`make sure` to `destroy` _your current_ `database`, and `THEN` (`re`)`create`
_another_ `Heroku Postgres` addon _for your_ `django-boards` application.
`Before` you `destroy` and `create` another `Heroku Postgres` addon, `make sure`
to `set` your `application` to `maintenance:on` by `running` _the following_
`command` in `Terminal` from `inside` the `root` of your `application`'s `local`
git `repository`:

```shell
heroku maintenance:on
```

`Which` _returns_ `something like` the `following`:

```shell
Enabling maintenance mode for ⬢ django-boards... done
```

We can `also` _turn on_ `maintenance mode` on `Heroku` _inside_ `our`
_application_ `Settings` _tab on_ `Heroku`.

## Static Files

_Locally_, as `long` as `DEBUG` is `set` to `True` in `settings.py`, `static`
files are `served` _automatically_ `by` the `runserver` command. `Django`
_looks_ `automatically` for `static` files` within` _each_ `app` _in a_ `folder`
_called_ 'static'. _Initially_, we `placed` our `static` files `in a`
_project-level_ `folder` _called_ 'static'.

_Locally_, `only` _two_ `settings` are `required` for `static` files:

```python
# django_boards/settings.py
STATIC_URL = 'static/'

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
```

`This` _already_ `exists` _in our_ `django_boards/settings.py`.
`STATICFILES_DIRS` _defines_ `additional locations` the `built-in` _staticfiles_
`app` will `look` for `static` files `outside` of an `app/static` directory. We,
_however_, _did not_ `set up` our `static` files `inside` our `apps`. We `set`
_them all_ `up` _in one_ `static` directory.

`Our` _local_ `Djang`o server (`runserver`) _is not_ `made` _for hosting_
`static` files in `production`. `Best practice` _is to_ `bundle` _all_ `static`
_files in_ `one directory` _and then_ `have` _the_ `production server` _serve
those_ `files`.

The `Django` collectstatic `command` _collects_ `static files` into
`STATIC_ROOT`. `STATIC_ROOT` _is the_ `absolute path` _to the_ `directory`
_where the_ `collectstatic` _command_ `will` _collect_ `static files` for
`deployment`. _This_ `means` _that we_ `have` to `add` a `STATIC_ROOT`
_definition in_ `django_boards/settings.py`:

```python
# what we already have
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = 'static/'

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
# what we need to add
# django_boards/settings.py
STATIC_ROOT = BASE_DIR / "staticfiles"
```

`Now` the `Static` _files_ `section` _should_ `look like` the `following`:

```python
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/
# This is the way we define STATIC_ROOT according to Heroku
STATIC_ROOT = BASE_DIR / "staticfiles"
STATIC_URL = 'static/'
```

`STATIC_ROOT` _ensures_ `Heroku` _can_ `serve` our `static files` _from the_
'staticfiles' directory in `production`, _and adding_
`'whitenoise.runserver_nostatic'` _to the_ `top` of `INSTALLED_APPS` _ensures_
`that` _we run_ `whitenoise`'s _runserver_ `implementation` _instead_ `of` the
`Django` default. `This` _is for_ `development-production` parity.

_Next_, _we run_ `python3 manage.py collectstatic` to `compile` our
`static files` _into a_ `folder` _called_ `staticfiles` _which_ `will` _be_
`located` _at the_ `root` _of our_ `django_boards` project, `in` the
`same directory` as `manage.py`. `When` I `ran` the `command`, `something like`
the `following` was `returned` in `Terminal`:

````shell
And in my case, the following was returned:

```shell
You have requested to collect static files at the destination
location as specified in your settings:

    /Users/mariacam/Python-Development/django-boards/django_boards/staticfiles

This will overwrite existing files!
Are you sure you want to do this?

Type 'yes' to continue, or 'no' to cancel: yes

1 static file copied to '/Users/mariacam/Python-Development/django-boards/django_boards/staticfiles', 135 unmodified.
````

`The` _command_ `results` _in the_ `following directory` and `structure`:

```shell
- staticfiles/
    - admin/
        - css/
        - img/
        - js/
    - css/
        - accounts.css/
        - app.css/
        - bootstrap.min.css/
        - styles.css
    - img/
        - pen-container.svg
        - user_avatar.svg
    - js/
        - app.js
        - copy-button.js
        - scroll-top.js
```

We `run` the `collectstatic` command for `Heroku`, and a `staticfiles` directory
is `generated` from `running` the `command`.

### Running the collectstatic command

`Django` _does not_ `have` _a built-in_ `solution` _for serving_ `static files`,
_at least_ `not` in `production` _when_ `DEBUG` _has_ `to` _be_ `False`. `What`
_we_ `have` _to do_ `now` _is set_ `DEBUG` to `False`, `which` _we already_
`did`.

```python
# django_boards/settings.py
# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = False
```

`Before` _we install_ `whitenoise`, we `run` the `collectstatic` command:

```shell
python3 manage.py collectstatic
```

We are then `prompted` _to_ `either` _type_ `yes` _to_ `continue` _or_ `no` _not
to_. I _typed_ `"yes"` to `continue`.

### Installing whitenoise

`Django` _does not_ `support` _serving_ `static files` in `production`.
_However_, _the fantastic_ `WhiteNoise` _project can_ `integrate` _into our_
`Django` application (on `Heroku`), and was `designed` _with this_ `purpose` in
`mind`.

`When` a `Django` application is `deployed` to `Heroku`,
`python manage.py collectstatic --noinput` _is run_ `automatically` _during the_
`build`. A `build` _will_ `fail` _if the_ `collectstatic` _step is_ `not`
successful.

`If` you `do not` _already have_ `whitenoise` installed, `run` _the following_
`command` _at the_ `root` _of your_ `local` Git `repository`. _For me_, it is
the `django-boards` directory `where` the `venv` directory `resides` and `where`
I `installed` _various_ `third-party` libraries:

```shell
(venv) django-boards pip install whitenoise
```

`Then` _re-run_ `pip freeze > requirements.txt` _to include_ `whitenoise`.

### Configuring whitenoise in django_boards/settings.py

_Next_, we `have` _to_ `add` _the_ `following` _to our_
`django_boards/settings.py` file:

```python
# django_boards/settings.py

IINSTALLED_APPS = [
    # Use WhiteNoise's runserver implementation instead of the Django default, for dev-prod parity.
    'whitenoise.runserver_nostatic',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.humanize',
    'boards',
    'accounts',
    'dotenv',
    'pylint',
    'graphviz',
    'djlint',
    'coverage',
    'widget_tweaks',
    'soupsieve',
    'bs4',
    'html5lib',
    'markdown',
    'avatar',
    'pygments',
    'nh3',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    # Django doesn't support serving static assets in a production-ready way, so we use the
    # excellent WhiteNoise package to do so instead. The WhiteNoise middleware must be listed
    # after Django's `SecurityMiddleware` so that security redirects are still performed.
    # See: https://whitenoise.readthedocs.io
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_ROOT = BASE_DIR / "staticfiles"
STATIC_URL = "static/"

# Don't store the original (un-hashed filename) version of static files, to reduce slug size:
# https://whitenoise.readthedocs.io/en/latest/django.html#WHITENOISE_KEEP_ONLY_HASHED_FILES
WHITENOISE_KEEP_ONLY_HASHED_FILES = True
```

## Media Files

`Usually` files `associated` _with the_ `FileField` _or_ `ImageField` model
`fields` _should be_ `treated` _as_ `media` files.

`Handling` _media_ `files` is `configured` in the `django_boards/settings.py`.

-   ` Similar` _to the_ `STATIC_URL`, the `MEDIA_URL` _is the_ `URL` _where_
    `users` _can_ `access` _media_ `files`.

-   `MEDIA_ROOT` _is the_ `absolute path` _to the_ `directory` _where our_
    `Django` application will `serve` our `media files` from.

### Media Files in development mode

Our `media files` _development_ `config` in `django_boards/settings.py`:

```python
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'
```

_However_, the `Django` _development_ `server` _doesn't serve_ `media files`
_by_ `default`. `But` we `can` (_and do_) `add` the `media root` as a
`static path` to the` ROOT_URLCONF` in our `project-level` URLs:

```python
# django_boards/urls.py
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
...
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

### Media Files in production

`When` _handling_ `media files` in `production`, we `don't have` _as many_
`options` _as we_ `do` _with_ `static files` _since_ `we` _can't use_
`WhiteNoise` _for serving_ `media files`. `Usually` _we might_ `want` _to use_
`Nginx` along with `django-storages` _to store_ `media files` _outside the_
`local file system` _where our_ `application` is `running` in `production`.

_However_, we are `not going` that `route` _because_ `we` _are_ `deploying` _to_
`Heroku`. We will `configure` our `media files` for `production` in `upcoming`
_part_ `32`.

## django_boards/settings.py up to this point

```python
"""
Django settings for django_boards project.

Generated by 'django_boards' using Django 5.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

import os
from pathlib import Path
import dj_database_url
from dotenv import load_dotenv
load_dotenv() # take environment variables from .env
dotenv_path = os.path.join(os.path.dirname(__file__), '.env')
load_dotenv(dotenv_path)

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# For user uploaded files
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
MEDIA_URL = '/media/'

AVATAR_PROVIDERS = (
    'avatar.providers.PrimaryAvatarProvider',
    'avatar.providers.LibRAvatarProvider',
    'avatar.providers.GravatarAvatarProvider',
    'avatar.providers.DefaultAvatarProvider',
)

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = str(os.getenv('SECRET_KEY'))

# The `DYNO` env var is set on Heroku CI, but it's not a real Heroku app, so we also have to
# explicitly exclude CI:
# https://devcenter.heroku.com/articles/heroku-ci#immutable-environment-variables
IS_HEROKU_APP = "DYNO" in os.environ and not "CI" in os.environ

# SECURITY WARNING: don't run with debug turned on in production!
if not IS_HEROKU_APP:
    DEBUG = True

# On Heroku, it's safe to use a wildcard for `ALLOWED_HOSTS``, since the Heroku router performs
# validation of the Host header in the incoming HTTP request. On other platforms you may need to
# list the expected hostnames explicitly in production to prevent HTTP Host header attacks. See:
# https://docs.djangoproject.com/en/5.1/ref/settings/#std-setting-ALLOWED_HOSTS
if IS_HEROKU_APP:
    ALLOWED_HOSTS = ["*"]
else:
    ALLOWED_HOSTS = ['localhost', '127.0.0.1']

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = False

# Application definition

INSTALLED_APPS = [
    # Use WhiteNoise's runserver implementation instead of the Django default, for dev-prod parity.
    'whitenoise.runserver_nostatic',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.humanize',
    'boards',
    'accounts',
    'dotenv',
    'pylint',
    'graphviz',
    'djlint',
    'coverage',
    'widget_tweaks',
    'soupsieve',
    'bs4',
    'html5lib',
    'markdown',
    'avatar',
    'pygments',
    'nh3',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    # Django doesn't support serving static assets in a production-ready way, so we use the
    # excellent WhiteNoise package to do so instead. The WhiteNoise middleware must be listed
    # after Django's `SecurityMiddleware` so that security redirects are still performed.
    # See: https://whitenoise.readthedocs.io
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'django_boards.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'templates')
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'django.template.context_processors.request',
            ],
        },
    },
]

WSGI_APPLICATION = 'django_boards.wsgi.application'

# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

if IS_HEROKU_APP:
    # In production on Heroku the database configuration is derived from the `DATABASE_URL`
    # environment variable by the dj-database-url package. `DATABASE_URL` will be set
    # automatically by Heroku when a database addon is attached to your Heroku app. See:
    # https://devcenter.heroku.com/articles/provisioning-heroku-postgres#application-config-vars
    # https://github.com/jazzband/dj-database-url
    DATABASES = {
        "default": dj_database_url.config(
            env="DATABASE_URL",
            conn_max_age=600,
            conn_health_checks=True,
            ssl_require=True,
        ),
    }
else:
    # When running locally in development or in CI, a sqlite database file will be used instead
    # to simplify initial setup. Longer term it's recommended to use Postgres locally too.
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }

# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_ROOT = BASE_DIR / 'staticfiles'

STATIC_URL = 'static/'

# Don't store the original (un-hashed filename) version of static files, to reduce slug size:
# https://whitenoise.readthedocs.io/en/latest/django.html#WHITENOISE_KEEP_ONLY_HASHED_FILES
WHITENOISE_KEEP_ONLY_HASHED_FILES = True

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

LOGIN_URL = 'login'

LOGOUT_REDIRECT_URL = 'index'

LOGIN_REDIRECT_URL = 'index'

EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
```

You can `view` this `version` of `django_boards/settings.py` at `git commit`
[2b99872](https://github.com/interglobalmedia/django-boards/blob/main/django_boards/django_boards/settings.py).

## Conclusion

In this section, I _modified_ `settings` in `django_boards/settings.py` for
`deployment` on `Heroku`. I `created` _a new_ `SECRET_KEY` for `use` on
`Heroku`, added `gunicorn`, `dj-database-url`, `psycopg2` and `psycopg2-binary`
packages, `created` a `requirements.txt` file, `created` a `Procfile`, `created`
a `.python-version` file, `discussed` the `purpose` of the `os` module, set
`DEBUG` to `False` on `Heroku`, `differentiated` between `DEBUG` value in
`local development` and `production` on `Heroku`, _configured_
`database access`, `ran` _the collectstatic_ `command` _for serving_
`static files` in `production`, and `installed` and `configured` whitenoise.

## Related Resources

-   [Django Boards repository on Github](https://github.com/interglobalmedia/django-boards)
-   [How to create a fullstack application using Django and Python Part 16](/blog/how-to-create-a-fullstack-application-using-django-and-python-part-16):
    **_mariadcampbell.com_**
-   [Hosting a Django Project on Heroku](https://realpython.com/django-hosting-on-heroku/):
    **_Real Python_**
-   [Deploying with Git](https://devcenter.heroku.com/articles/git): **_Heroku
    documentation_**
-   [Running Apps Locally](https://devcenter.heroku.com/articles/heroku-local):
    Heroku documentation
-   [Django and Static Assets](https://devcenter.heroku.com/articles/django-assets):
    **_Heroku documentation_**
-   [Using WhiteNoise with Django](https://whitenoise.readthedocs.io/en/latest/django.html#WHITENOISE_KEEP_ONLY_HASHED_FILES):
    **_Whitenoise documentation_**
-   [Specifying a Python Version](https://devcenter.heroku.com/articles/python-runtimes#:~:text=Whenever%20you%20change%20Python%20runtime,in%20your%20active%20virtual%20environment.):
    **_Heroku documentation_**
-   [How to deploy with WSGI](https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/):
    **_Django documentation_**
-   [Heroku Postgres](https://devcenter.heroku.com/articles/heroku-postgresql):
    **_Heroku documentation_**
-   [Deploying Your Django REST API on Heroku: A Beginner’s Guide](https://medium.com/@nagarjunmallesh/deploying-your-django-rest-api-on-heroku-a-beginners-guide-10373d9b6ddd):
    **_by nagarjun mallesh, medium.com_**

## Related Posts

-   [How to create a fullstack application using Django and Python Table of Contents](/blog/how-to-create-a-fullstack-application-using-django-and-python-table-of-contents)
